## 每題說明

# 1 (邏輯閘、布林邏輯)

## Not
* **完成方式**: 參考教授設計
* **使用元件**: `Nand`
* **學習過程**: 透過 GPT 了解 NOT 的邏輯定義。當輸入為 0 時輸出 1，反之亦然。
* ![NOT電路圖]()

## And
* **完成方式**: 原創實作
* **使用元件**: `Nand`, `Not`
* **學習過程**: 只有當兩個輸入都為 1 時才輸出 1。使用 GPT 驗證程式邏輯的正確性。

## Or
* **完成方式**: 原創實作
* **使用元件**: `Nand`, `Not`
* **學習過程**: 只要任一輸入為 1，輸出即為 1。透過 GPT 輔助確認定義。

## XOr
* **完成方式**: 使用 GPT 改進邏輯
* **使用元件**: `And`, `Not`, `Or`
* **學習過程**: 兩個輸入不同時輸出 1。透過 AI 驗證 XOr 在不同組合下的輸出結果。

## Mux
* **完成方式**: **Gemini 幫忙改寫**
* **使用元件**: `And`, `Not`, `Or`
* **學習過程**: 理解多工器作為「受控開關」的角色，透過 `sel` 決定輸出 A 或 B。


## DMux
* **完成方式**: **Gemini 幫忙改寫**
* **使用元件**: `Not`, `And`
* **學習過程**: 理解一分多的原理，將輸入訊號根據選擇線導向特定的輸出通道。

## Mux16 / Mux4Way16 / Mux8Way16
* **完成方式**: **Gemini 撰寫與修正**
* **使用元件**: `Mux`, `Mux16`
* **學習過程**: 學習如何處理 16-bit 匯流排，並透過分層解碼的方式從多組輸入中選出正確資料。

---

# 2 (布林運算)

## HalfAdder & FullAdder
* **完成方式**: **Gemini 撰寫與修正**
* **使用元件**: `XOr`, `And`, `Or`, `HalfAdder`
* **核心邏輯**: 處理位元相加產生的 Sum 與 Carry。全加器則進一步處理來自低位數的進位輸入。

## Add16 & Inc16
* **完成方式**: **Gemini 撰寫** (Add16) / 參考教授 (Inc16)
* **使用元件**: `FullAdder`, `Add16`
* **核心邏輯**: 將 16 個全加器串聯實現連波進位。Inc16 則專注於將輸入數值進行遞增運算。

## ALU (算術邏輯單元)
* **完成方式**: **使用 Gemini 撰寫**
* **核心邏輯**: 這是電腦的核心大腦。透過 6 個控制位元執行算術或邏輯運算，並輸出 `zr` 與 `ng` 狀態標誌。


---

# 3 (時序運算)

## Bit & Register
* **完成方式**: **Gemini 協助撰寫**
* **核心邏輯**: 利用 DFF 鎖住訊號。根據 `load` 指令決定是載入新值還是保持原狀。

## RAM8 至 RAM16K
* **完成方式**: **Gemini 協助撰寫**
* **結構**: 採用遞迴堆疊結構。透過位址 (Address) 解碼，在多層記憶體單元中精確存取特定暫存器。

## PC (程式計數器)
* **完成方式**: **Gemini 協助撰寫**
* **核心邏輯**: 管理電腦指令執行的順序，支援 Reset、Load 與 Inc 三種優先邏輯控制。

---

# 4 (機器語言)

## fill.asm
* **完成方式**: **Gemini 撰寫**
* **運作**: 監聽鍵盤 (KBD) 狀態。當有按鍵按下時，透過循環填滿螢幕記憶體，達成黑白畫面切換。

## Mult.asm
* **完成方式**: **Gemini 撰寫**
* **運作**: 使用重複加法演算法實作乘法功能，並將結果存入 R2。

---

# 5 (計算機架構)

## Memory
* **完成方式**: 參考教授設計
* **定義**: 建立記憶體映射系統，將 RAM、Screen 與 Keyboard 整合在同一個定址空間。

## CPU & Computer
* **完成方式**: 參考教授設計
* **運作**: CPU 負責解碼與執行指令。Computer 則將 CPU、ROM 與 Memory 接合，完成「取指令-執行」的循環。


[Image of Von Neumann architecture diagram]


---

### 實作感悟
這次專案讓我學會如何將抽象的數位邏輯具現化。在遇到複雜的 CPU 或 RAM 結構時，我參考了教授的原始碼來建立骨架，並利用 **Gemini** 幫我解釋細部的位元控制邏輯，這對我在 Debug 過程中幫助很大。雖然有些程式碼是參考 AI 的建議，但透過反覆驗證與修正，我才真正理解了硬體與軟體之間的連結。
